worker_processes 1;
error_log stderr debug;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;/usr/local/openresty/lualib/?.lua;;";

    lua_shared_dict providers_cache 10m;

    init_worker_by_lua_block {
        local manager = require "providers_manager"
        local providers_cache = ngx.shared.providers_cache

        -- Обновляем кэш провайдеров
        local function update_providers(premature)
            if premature then
                return
            end

            ngx.log(ngx.INFO, "Updating providers cache")
            local file_path = "/usr/local/openresty/nginx/providers.json"

            -- Обновляем кэш с провайдерами
            local success, err = pcall(function()
                manager.cache_providers(providers_cache, file_path)
            end)

            if not success then
                ngx.log(ngx.ERR, "Failed to update providers: ", err)
            end
        end

        -- Запуск обновления при старте и каждые 60 секунд
        local ok, err = ngx.timer.at(0, update_providers)
        if not ok then
            ngx.log(ngx.ERR, "Failed to schedule initial provider update: ", err)
        end

        local ok, err = ngx.timer.every(60, update_providers)
        if not ok then
            ngx.log(ngx.ERR, "Failed to schedule periodic provider update: ", err)
        end
    }

    upstream dynamic_balancer {
        balancer_by_lua_block {
            local manager = require "providers_manager"
            local cache = ngx.shared.providers_cache

            -- Track the number of attempts
            if not ngx.ctx.try_count then
                ngx.ctx.try_count = 1
            else
                ngx.ctx.try_count = ngx.ctx.try_count + 1
            end

            ngx.log(ngx.DEBUG, "Attempt: ", ngx.ctx.try_count)

            -- Получаем провайдера из кэша
            local provider, err = manager.get_provider_for_attempt(cache, ngx.ctx.try_count)
            if not provider then
                ngx.log(ngx.ERR, "No more providers available: ", err)
                return ngx.exit(502) -- Ошибка, провайдеры закончились
            end

            ngx.log(ngx.INFO, "Using provider: ", provider.host, " (IP: ", provider.host, ") for attempt: ", ngx.ctx.try_count)

            -- Настраиваем балансировщик
            local balancer = require "ngx.balancer"
            local ok, set_peer_err = balancer.set_current_peer(provider.host, provider.port)
            if not ok then
                ngx.log(ngx.ERR, "Failed to set peer: ", set_peer_err)
                return ngx.exit(500)
            end

            -- Устанавливаем заголовок Authorization, если требуется
            if provider.auth_header then
                ngx.req.set_header("Authorization", provider.auth_header)
                ngx.log(ngx.INFO, "Set Authorization header")
            end

            ngx.req.set_header("Host", provider.host)
            ngx.log(ngx.INFO, "Set Host header: ", provider.host)
        }
    }

    server {
        listen 8080;
        server_name localhost;

        # HTTP basic authentication
        auth_basic "Restricted Access";
        auth_basic_user_file /etc/nginx/.htpasswd;

        proxy_next_upstream error timeout invalid_header http_429 http_500 http_502 http_503 http_504;
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        client_max_body_size 50M;

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://dynamic_balancer;

            #access_log /var/log/nginx/access.log;
        }
    }
}
