worker_processes 1;
error_log stderr info;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}


http {
    lua_shared_dict providers_cache 10m;

    # Define the default provider in Nginx
    set $default_provider_url "https://mainnet.infura.io/v3/xxx";
    set $default_provider_auth "";

    init_worker_by_lua_block {
        local manager = require "providers_manager"
        local providers_cache = ngx.shared.providers_cache

        -- Retrieve the default provider from Nginx
        local default_providers = {
            {
                url = ngx.var.default_provider_url,
                auth_header = ngx.var.default_provider_auth
            }
        }

        local file_path = "/etc/nginx/providers.json"

        local function update_providers()
            manager.cache_providers(providers_cache, file_path, default_providers)
        end

        -- Initial loading of providers
        update_providers()

        -- Timer to refresh the provider configuration every 30 seconds
        local ok, err = ngx.timer.every(30, update_providers)
        if not ok then
            ngx.log(ngx.ERR, "Failed to create timer for providers config reload: ", err)
        end
    }

    server {
        listen 8080;
        server_name localhost;

        # Enable HTTP basic authentication
        auth_basic "Restricted Access"; # Text shown in the login prompt
        auth_basic_user_file /etc/nginx/.htpasswd;

        proxy_next_upstream error timeout invalid_header http_401 http_429 http_500 http_502 http_503 http_504;
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        client_max_body_size 50M;

        balancer_by_lua_block {
            local manager = require "providers_manager"
            local cache = ngx.shared.providers_cache

            -- Pass the default provider from Nginx
            local default_providers = {
                {
                    url = ngx.var.default_provider_url,
                    auth_header = ngx.var.default_provider_auth
                }
            }

            -- Track the number of attempts
            if not ngx.ctx.try_count then
                ngx.ctx.try_count = 1
            else
                ngx.ctx.try_count = ngx.ctx.try_count + 1
            end

            -- Retrieve the current provider
            local provider, err = manager.get_provider_for_attempt(cache, ngx.ctx.try_count, default_providers)
            if not provider then
                ngx.log(ngx.ERR, "Failed to select provider: ", err)
                return ngx.exit(502) -- All providers have been tried
            end

            ngx.log(ngx.INFO, "Using provider: ", provider.host, " attempt: ", ngx.ctx.try_count)

            local balancer = require "ngx.balancer"
            local ok, set_peer_err = balancer.set_current_peer(provider.host, provider.port)
            if not ok then
                ngx.log(ngx.ERR, "Failed to set peer: ", set_peer_err)
                return ngx.exit(500)
            end

            if provider.auth_header then
                ngx.req.set_header("Authorization", provider.auth_header)
            else
                ngx.req.clear_header("Authorization")
            end

            ngx.req.set_header("Host", provider.host)
        }

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://placeholder-set-by-balancer;
        }
    }
}
