worker_processes 1;
error_log stderr debug;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
	lua_package_path "/usr/local/openresty/nginx/lua/?.lua;/usr/local/openresty/lualib/?.lua;;";

    lua_shared_dict providers_cache 10m;

	init_worker_by_lua_block {
	    local manager = require "providers_manager"
	    local providers_cache = ngx.shared.providers_cache

	    local function update_providers(premature)
	        if premature then
	            return
	        end

	        ngx.log(ngx.ERR, "Updating providers")
	        local resolver = require "resty.dns.resolver"
	        local cjson = require "cjson"

	        local file_path = "/usr/local/openresty/nginx/providers.json"

	        -- Настраиваем резолвер
	        local dns, err = resolver:new{
	            nameservers = {"8.8.8.8", "8.8.4.4"},  -- Google DNS
	            retrans = 5,
	            timeout = 2000,  -- 2 секунды
	        }
	        if not dns then
	            ngx.log(ngx.ERR, "Failed to create DNS resolver: ", err)
	            return
	        end

	        -- Читаем файл providers.json
	        local file = io.open(file_path, "r")
	        if not file then
	            ngx.log(ngx.ERR, "Failed to open providers file: ", file_path)
	            return
	        end

	        local content = file:read("*a")
	        file:close()

	        local ok, providers = pcall(function()
	            return cjson.decode(content)
	        end)

	        if not ok or type(providers) ~= "table" then
	            ngx.log(ngx.ERR, "Failed to parse providers.json: ", content)
	            return
	        end

	        -- Кэшируем IP-адреса провайдеров
	        providers_cache:flush_all() -- Очищаем старые записи
	        for _, provider in ipairs(providers) do
	            local answers, err = dns:query(provider.url:match("^https://([^/]+)")) -- Извлекаем хост
	            if not answers then
	                ngx.log(ngx.ERR, "DNS query failed for ", provider.url, ": ", err)
	            else
	                for _, ans in ipairs(answers) do
	                    if ans.address then
	                        local cache_entry = {
	                            ip = ans.address,
	                            auth_header = provider.auth_header or nil
	                        }
	                        providers_cache:set(provider.url, cjson.encode(cache_entry)) -- Сохраняем в кэш
	                        ngx.log(ngx.INFO, "Cached provider: ", provider.url, " -> ", ans.address)
	                        break -- Берём первый IP
	                    end
	                end
	            end
	        end
	    end

	    -- Запуск обновления через таймер
	    local ok, err = ngx.timer.at(0, update_providers)
	    if not ok then
	        ngx.log(ngx.ERR, "Failed to schedule initial provider update: ", err)
	    end

	    -- Запуск регулярного обновления
	    local ok, err = ngx.timer.every(60, update_providers)
	    if not ok then
	        ngx.log(ngx.ERR, "Failed to schedule periodic provider update: ", err)
	    end
	}

    upstream dynamic_balancer {
        balancer_by_lua_block {
            ngx.log(ngx.ERR, "Balancing request")
            local manager = require "providers_manager"
            local cache = ngx.shared.providers_cache

            -- Pass the default provider from Nginx
            local default_providers = {
                {
                    url = "https://mainnet.infura.io/v3/xxx",
                    auth_header = ""
                }
            }

            -- Track the number of attempts
            if not ngx.ctx.try_count then
                ngx.ctx.try_count = 1
            else
                ngx.ctx.try_count = ngx.ctx.try_count + 1
            end

            ngx.log(ngx.DEBUG, "Attempt: ", ngx.ctx.try_count)

            -- Retrieve the current provider
            local provider, err = manager.get_provider_for_attempt(cache, ngx.ctx.try_count, default_providers)
            if not provider then
                ngx.log(ngx.ERR, "Failed to select provider: ", err)
                return ngx.exit(502) -- All providers have been tried
            end

            ngx.log(ngx.INFO, "Using provider: ", provider.host, " attempt: ", ngx.ctx.try_count)

			local balancer = require "ngx.balancer"
			local ok, set_peer_err = balancer.set_current_peer(provider.host, provider.port)
			if not ok then
			    ngx.log(ngx.ERR, "Failed to set peer: ", set_peer_err)
			    return ngx.exit(500)
			end

			-- Установка заголовка Authorization, если токен указан
			if provider.auth_header then
			    ngx.req.set_header("Authorization", provider.auth_header)
			    ngx.log(ngx.INFO, "Set Authorization header")
			else
			    ngx.req.clear_header("Authorization")
			    ngx.log(ngx.INFO, "Cleared Authorization header")
			end

			ngx.req.set_header("Host", provider.host)
			ngx.log(ngx.INFO, "Set Host header: ", provider.host)

            ngx.log(ngx.INFO, "Request headers: ", ngx.req.get_headers())
            ngx.log(ngx.INFO, "Request body: ", ngx.var.request_body)
        }
    }
    server {
        listen 8080;
        server_name localhost;

        # Enable HTTP basic authentication
        auth_basic "Restricted Access"; # Text shown in the login prompt
        auth_basic_user_file /etc/nginx/.htpasswd;

        proxy_next_upstream error timeout invalid_header http_429 http_500 http_502 http_503 http_504;
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        client_max_body_size 50M;

        location / {
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://dynamic_balancer;

            # Log debug information for incoming requests
            log_subrequest on;
#             access_log /var/log/nginx/access.log;
        }
    }

}

